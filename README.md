[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/MUFtVp-N)
# miniproject-erlang
# PCLT - Actor-based Concurrency Module

## Report

All tasks are implemented using the same code the only difference is the parameters used when starting the system.

The system starts by checking that the configuration is valid (Ex: the number of trucks is positive).
After that the package list is generated using the provided configuration.
Packages are represented by and identifier and a weight that is random inside the provided range.
The system is made up of 4 different processes with some of them having multiple instances.\
\
The **factory** process takes as input the list of packages(they could also have been generated by the factory) and hands out packages
to any process that requests them until there are no more. The factory interface is made up two functions: \
`factory:request(Pid)`: requests a package from the factory and blocks until either the package is received or the factory runs out of packages. \
`factory:shutdown(Pid)`: shuts down the factory. \
\
The **Belt** process takes as input the factory process id and the truck queue process id. There are multiple instances of this process, one per belt. The belt doesn't have an interface as it is not meant to be directly interacted with. It will start by requesting a package from the factory. After it obtains a package it will request the next truck in the truck queue until it can load the package at which point it goes back to requesting a package from the factory. If there are no more packages in the factory it will exit. \
\
The **Truck Queue** process is, just as the name implies, a queue for the trucks in the system. Its interface is made up of two functions: \
`truck:queue_push(Pid, TruckPid)`: inserts a truck in the queue or gives it to a process waiting for a truck if one exists. \
`truck:queue_pop(Pid)`: blocks the calling process until a truck is available. \
\
The **Truck** process takes as input the process id for the truck queue, the truck's capacity, minimum wait time and maximum wait time.
There are multiple instances of this process, one per truck in the system. The interface is made up of three functions: \
`truck:load(Pid, Package)`: attempts to load a package in the truck. this operation will either fails or succeeds and tells the caller if the truck still has positive amount of capacity left. \
`truck:dispatch(Pid)`: sends the truck off with the packages that it contains. After a random amount of wait time, inside the range given when the truck was created, it will return back to the queue. \
\
After all the processes are started the calling process will block until they have all terminated.

### Running the program
```sh
# task 1
./run.sh

# task 2
MIN_PACKAGE_WEIGHT=1 MAX_PACKAGE_WEIGHT=10 ./run.sh

# task 3
MIN_PACKAGE_WEIGHT=1 MAX_PACKAGE_WEIGHT=10 MIN_TRUCK_DISPATCH_TIME=1000 MAX_TRUCK_DISPATCH_TIME=4000 ./run.sh
```

## Erlang Lab Class #2 - Miniproject

**Note that the mini-project is the same for the three modules (Go, Rust, Erlang).** 

**DEADLINE** 27/11/2024 23:59

---
To submit your answers, simply push your files onto the repository. The problem will be graded.

---

## Product Distribution System
The goal of this mini-project is to design and implement a concurrent product distribution system using Erlang’s process-based concurrency model. The system will simulate a factory that handles the shipment of products to clients using a fleet of trucks and multiple conveyor belts.

### General Requirements
* Concurrency: The system must use independent Erlang processes to model conveyor belts and trucks.
* Deadlock-Free: Ensure the absence of deadlocks; all packages must eventually be loaded onto trucks.
* Progress Guarantee: All parts of the system must keep working to process and deliver packages.
* Message Passing: Use Erlang’s message-passing mechanisms for synchronization and coordination.

## Task 1: Core System
#### Goal: Implement the basic system with continuous operation.

* Implement the core system.
* Must account for multiple conveyor belts being “fed” packages continuously and multiple trucks.
* Assume that when a truck is full it can be replaced instantly.
* Conveyor belts can run continuously.
* You need not be very realistic or precise with time, but the relative order of events should be the expected one: a package is loaded onto a conveyor belt before it gets loaded onto a non-full truck.
* The order of events must follow logical steps: a package is created, placed on a conveyor belt, and then loaded onto a non-full truck.

**Note:** Add a small report to the task 1 folder that explains what correctness properties your system has and what achieves them.

## Task 2: Variable Package Sizes
### Goal: Extend the system to support packages of different sizes.

#### Enhancements:
* Each package generated by a conveyor belt has a size (randomly determined or specified).
* Trucks are loaded unevenly based on the size of the packages.
#### Behavior:
* A truck can only load a package if it has enough remaining capacity.
* The system must log package sizes and the updated capacity of trucks after each loading.
  
**Note:** Add a small report to the task 2 folder that explains what correctness properties your system has and what achieves them.

## Task 3: Non-Instant Truck Replacement
#### Goal: Extend the system to introduce delays for replacing trucks.

#### Enhancements:
* When a truck is full, it takes a non-zero amount of time to be replaced.
* Conveyor belts must pause their operation while waiting for the replacement of a truck at their endpoint.
#### Behavior:
* During truck replacement, a conveyor belt must stop feeding packages to avoid overflows.
* Once the truck is replaced, the conveyor belt resumes its operation.

**Note:** Add a small report to the task 3 folder that explains what correctness properties your system has and what achieves them.
